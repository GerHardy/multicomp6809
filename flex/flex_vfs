#!/usr/bin/perl
#
# Manipulator for FLEX disk images. Designed to act as a virtual file system
# for disk analysis, extract, import, copy, creation, conversion.
#
# Mostly designed for interactive use but also allows limited non-interactive
# use.
#
# Neal Crook, July 2015.

# next: break down SIR
# next: label
# next: implement "then" as command separator and allow command-line
# and add to help.
# implement clone label dir link
# then new info copy delete check scrub
# finally import export repair
# TODO: record inode so that we cannot double-mount a drive?


use strict;
no strict 'refs'; # CLI makes subroutine from command name.
use warnings;


# FLEX constants
#
# Tracks are numbered 0..n
# Sectors are numbered 1..n
#
# The .dsk image contains a linear sequence of sector-sized data.
# This program uses the word "block" to refer to the linear offset.
# For example, track=0, sector=1 is block 0.
# block <-> track/sector conversion is easy for the first track
# but requires knowledge of the system information record (SIR)
# in order to do conversions beyond the first track.
my %flx;
$flx{BYTES_SECTOR} = 256;
$flx{SIR_BLK} = 2; # Track=0 Sector=3
$flx{LDR_BLK} = 0; # Track=0 Sector=1
$flx{DIR_BLK} = 4; # Track=0 Sector=5



# Data structure
# $dsk[0..3]
# $dsk[n]->{mounted} boolean
# $dsk[n]->{handle} file handle
# $dsk[n]->{bytes_blk} 256 for dsk file, 512 for img file
# $dsk[n]->{blks} number of blocks
# $dsk[n]->{filename} file name by which file was accessed
# filled in by reading SIR when disk was mounted
# $dsk[n]->{sir}->{data} array of data
# $dsk[n]->{sir}->{NAME} decoded fields of sir.
# $dsk[n]->{sir}->{NUM}

my @dsk;

# Boot sector. Binary string. Undefined if not loaded.
my $boot;


# Command-line interpreter
while (1) {
    print "flex_vfs: ";
    my $cmd = <>;
    chomp $cmd;
    next if ($cmd eq "");
    my @bits = split " ", $cmd;
    my $sub = "cmd_$bits[0]";
    if (defined(&{$sub})) {
        shift @bits;
        &{$sub}(@bits);
    }
    else {
        print "ERROR: no command $bits[0]\n";
    }
}

#################################################################
#################################################################
## Commands

sub cmd_mount {
    my ($drive, $file, $format) = arg_check('v h of', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is already mounted.\n";
    }
    else {
        if (open $dsk[$drive]->{handle}, '+<', $file) {
            # so far so good
            $dsk[$drive]->{bytes_blk} = $format eq 'dsk' ? 256 : 512;

            my $sir = rd_dts($drive, 0, 3);
            my @sir = unpack("C*", $sir);
            $dsk[$drive]->{sir}->{data} = \@sir;

            # TODO read through file to deduce this
            $dsk[$drive]->{blks} = 24;

            decode_sir($drive);

            # sanity check
            if (($dsk[$drive]->{sir}->{data}->[0] == 0) and ($dsk[$drive]->{sir}->{data}->[1] == 0)) {
                $dsk[$drive]->{filename} = $file;
                $dsk[$drive]->{mounted} = 1;
            }
            else {
                print "ERROR first two bytes of SIR were non-zero. Mount aborted.\n"
            }
        }
        else {
            # Unlikely - it opened OK in arg_check
            print "ERROR could not re-open $file\n";
        }
    }
}


sub cmd_clone {
    print "clone TODO - not yet implemented\n";
# quite easy - copy from other prog
}


sub cmd_info {
    for my $drive (0..3) {
        print "Drive $drive: ";
        if ($dsk[$drive]->{mounted}) {
            print "Host file:    $dsk[$drive]->{filename}\n";
            describe_sir($drive);
        }
        else {
            print "not mounted\n";
        }
    }
}


sub cmd_umount {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    # silently ignored if this drive number is not currently in use.
    if ($dsk[$drive]->{mounted}) {
        close $dsk[$drive]->{handle};
        $dsk[$drive]->{mounted} = 0;
    }
}


sub cmd_new {
    print "new TODO - not yet implemented\n";
}


sub cmd_copy {
    print "copy TODO - not yet implemented\n";
}


sub cmd_label {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
# TODO
# TODO update in {sir} and then flush to disk? 
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_export {
    print "export TODO - not yet implemented\n";
}


sub cmd_import {
    print "import TODO - not yet implemented\n";
}


sub cmd_dir {
    print "dir TODO - not yet implemented\n";
}


sub cmd_delete {
    print "delete TODO - not yet implemented\n";
}


sub cmd_link {
    print "link TODO - not yet implemented\n";
}


sub cmd_fix {
    print "fix TODO - not yet implemented\n";
}


sub cmd_rdboot {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        my $data = rd_dts($drive, 0, 1);
        if (defined $data) {
            $boot = $data;
        }
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_wrboot {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if (defined $boot) {
        if ($dsk[$drive]->{mounted}) {
            wr_dts($drive, 0, 1, $boot);
        }
        else {
            print "ERROR virtual drive $drive is not mounted\n";
        }
    }
    else {
        print "ERROR boot sector not loaded. Use rdboot or rdbootfile\n";
    }
}


sub cmd_rdbootfile {
    my $file = $_[0];
    if (open IN, $file) {
        my $data;
        my $got = read IN, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            my $tmp;
            $got = read IN, $tmp, 1;
            if ($got == 0) {
                # it's all good.
                $boot = $data;
            }
            else {
                print "ERROR too much data - expected exactly $flx{BYTES_SECTOR} bytes\n";
            }
        }
        else {
            print "ERROR not enough data - expected $flx{BYTES_SECTOR} bytes\n";
        }
        close IN;
    }
    else {
        print "ERROR could not open $file\n";
    }
}


sub cmd_check {
    print "check TODO - not yet implemented\n";
}


sub cmd_scrub {
    print "scrub TODO - not yet implemented\n";
}


sub cmd_repair {
    print "repair TODO - not yet implemented\n";
}


sub cmd_quit {
    cmd_exit();
}


sub cmd_exit {
    cmd_umount(0);
    cmd_umount(1);
    cmd_umount(2);
    cmd_umount(3);
    exit;
}


sub cmd_help {
    my $help_for = $_[0];
    if (defined $help_for) {
        help_for($help_for);
    }
    else {
        help_generic();
    }
}


#################################################################
#################################################################
# Subroutines

# string of expected argument formats, followed by argument list
# prints error message for any mismatch.
# returns args if all OK.
# otherwise returns nothing.
# "v a b", ("arg1", "arg2", "arg3", "arg4)
# argument formats are:
# v - virtual drive number
# h - existing file in host filesystem
# of - optional file format: dsk or img, also inferred from h
sub arg_check {
    my @expected = split " ",(shift @_);
    my %format;
    my $i = 0;
    foreach my $f (@expected) {
        # allows random access later on..
        $format{$f} = $i;

        if ($f eq 'v') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected virtual drive number\n";
                return;
            }
            if (($_[$i] ne "0") and ($_[$i] ne "1") and
                ($_[$i] ne "2") and($_[$i] ne "3")) {
                print "ERROR $_[$i] is not a legal virtual drive number\n";
                return;
            }
        }
        elsif ($f eq 'h') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            if (open my $tmp, '+<', $_[$i]) {
                # all good
                close $tmp;
            }
            else {
                print "ERROR could not open $_[$i]\n";
                return;
            }
        }
        elsif ($f eq 'of') {
            # optional format. If present, takes precedence and must be img or dsk
            # If absent, inferred from file extension of {h} argument. Incoming
            # arguments changed to declare the format.

            if ((defined $_[$i]) && (($_[$i] eq 'img') or ($_[$i] eq 'dsk'))) {
                # explicit format takes priority. Nothing more to do.
            }
            else {
                # extract extension from filename elsewhere in argument list
                my @ext = split /\./, $_[$format{h}];
                if ((defined $ext[-1]) && (($ext[-1] eq 'img') or ($ext[-1] eq 'dsk'))) {
                    # change incoming argument so it's always present/valid
                    $_[$i] = $ext[-1];
                }
                else {
                    print "ERROR could not infer format. Specify dsk or img\n";
                    return;
                }
            }
        }
        else {
            die "FATAL interal error - unknown format $f\n";
        }
        $i = $i + 1;
    }
    return @_;
}


# read a sector, return data as a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and read 1st copy of the data
sub rd_dts {
    my ($drive, $trk, $sct) = @_;
    my $seek;
    my $data;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        die "Need to know geometry in rd_dts";
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $got = read $dsk[$drive]->{handle}, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            return $data;
        }
        else {
            die "Could not read $flx{BYTES_SECTOR} bytes at offset $seek on drive $drive";
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}


# write a sector, incoming data is a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and write 2 copies of the data
sub wr_dts {
    my ($drive, $trk, $sct, $data) = @_;
    my $seek;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        die "Need to know geometry in rd_dts";
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $fh = $dsk[$drive]->{handle};
        print $fh $data;
        if ($dsk[$drive]->{bytes_blk} != $flx{BYTES_SECTOR}) {
            # 2nd copy
            print $fh $data;
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}

# decode bytes of the sir into a data structure that makes it
# easy to access
sub decode_sir {
    my $drive = $_[0];

    my $sir = $dsk[$drive]->{sir}->{data};

    # SIR format is described in section 9.1.5 of the 6809FAG
    $dsk[$drive]->{sir}->{LNK}     = 256 * $sir->[0] + $sir->[1];
    my $name = '';
    for my $i (16..16+11-1) {
        $name = $name . chr $dsk[$drive]->{sir}->{data}->[$i];
    }
    $dsk[$drive]->{sir}->{NAME}    = $name;
    $dsk[$drive]->{sir}->{NUM}     = 256 * $sir->[27] + $sir->[28];
    $dsk[$drive]->{sir}->{FIRST_T} = $sir->[29];
    $dsk[$drive]->{sir}->{FIRST_S} = $sir->[30];
    $dsk[$drive]->{sir}->{LAST_T}  = $sir->[31];
    $dsk[$drive]->{sir}->{LAST_S}  = $sir->[32];
    $dsk[$drive]->{sir}->{FREE}    = 256 * $sir->[33] + $sir->[34];
    $dsk[$drive]->{sir}->{DATE_M}  = $sir->[35];
    $dsk[$drive]->{sir}->{DATE_D}  = $sir->[36];
    $dsk[$drive]->{sir}->{DATE_Y}  = $sir->[37] %100; # Y2K fixup
    $dsk[$drive]->{sir}->{MAX_T}   = $sir->[38];
    $dsk[$drive]->{sir}->{MAX_S}   = $sir->[39];

    # need to make a guess now so that the directory can be inspected. Verify the guess
    # later on and confess if we got it wrong.
    $dsk[$drive]->{sir}->{T1_OFFSET} = $dsk[$drive]->{sir}->{MAX_S};
}

# Dump the SIR in human-readable format
sub describe_sir {
    my $drive = $_[0];
    my $i = "        ";

    printf "$i Image size:   %d blocks (%d bytes)\n",
    $dsk[$drive]->{blks}, $dsk[$drive]->{blks} * $dsk[$drive]->{bytes_blk};
# TODO
#        printf "%d blocks with data first/second half mismatches\n", $dsk[$drive]->{sir}->{SDMISMATCH};

    printf "$i Disk name:   %12s\n", $dsk[$drive]->{sir}->{NAME};
    printf "$i Disk number:  %d\n",  $dsk[$drive]->{sir}->{NUM};
    printf "$i Disk date:    %02d-%02d-%02d\n", $dsk[$drive]->{sir}->{DATE_M},
    $dsk[$drive]->{sir}->{DATE_D}, $dsk[$drive]->{sir}->{DATE_Y};
    printf "$i Free sectors: %d. Free chain t%02d,s%02d - t%02d,s%02d\n",
    $dsk[$drive]->{sir}->{FREE},
    $dsk[$drive]->{sir}->{FIRST_T}, $dsk[$drive]->{sir}->{FIRST_S},
    $dsk[$drive]->{sir}->{LAST_T}, $dsk[$drive]->{sir}->{LAST_S};
    printf "$i Range:        t00-t%02s, s01-s%02s\n",
    $dsk[$drive]->{sir}->{MAX_T}, $dsk[$drive]->{sir}->{MAX_S};
    printf "$i Trk0 sectors: $dsk[$drive]->{sir}->{T1_OFFSET}\n";
}



# return true if $drive is 0-3, false otherwise.
# TODO may never be called now?
sub legal_drive {
    my $drive = $_[0];
    return ((defined $drive) && (($drive eq '0') or ($drive eq '1') or ($drive eq '2') or ($drive eq '3')));
}

# if $format is non-blank it must be img or dsk.
# if $format is blank infer format from extension of $file
# return format or '' if unknown.
# TODO may never be called now?
sub infer_format {
    my ($file, $format) = @_;

    if ((defined $format) && (($format eq 'img') or ($format eq 'dsk'))) {
        # explicit format takes priority
        return $format;
    }
    else {
        my @ext = split /\./, $file;
        print "Got $file $ext[0] $ext[1] $ext[-1]\n";
        if ((defined $ext[-1]) && (($ext[-1] eq 'img') or ($ext[-1] eq 'dsk'))) {
            return $ext[-1];
        }
    }
    return '';
}


sub help_for {
    my $cmd = $_[0];
    if ($cmd eq 'mount') {
        print <<EOF
    mount <virtual drive number> <file on host filesystem> [format]

    Associate a file on the host filesystem with a virtual drive number.

    Virtual drive number is 0,1,2 or 3.
    Legal formats are "dsk" (256 bytes per sector) and "img" (256
    bytes per sector but doubled, on a 512-byte boundary)

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    Examples:
    mount 1 ../../foo.dsk
    mount 0 advent.dsk
    mount 2 system.img
    mount 0 flex09.zzz img
    mount 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'clone') {
        print <<EOF
    clone <virtual drive number> <file on host filesystem> [format]

    Make a copy of a virtual drive as a file on the host filesystem

    Virtual drive number is 0,1,2 or 3.
    Legal formats are "dsk" (256 bytes per sector) and "img" (256
    bytes per sector but doubled, on a 512-byte boundary)

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    If the format is different from the format of the virtual drive,
    format conversion will be performed.

    Examples:
    clone 1 ../../foo.dsk
    clone 0 advent.dsk
    clone 2 system.img
    clone 0 flex09.zzz img
    clone 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'umount') {
        print <<EOF
    umount <virtual drive number>

    Close file associated with virtual drive number and make that virtual
    drive number available for reuse.

    Examples:
    umount 0
    umount 2
EOF
    }
    elsif ($cmd eq 'new') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'copy') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'label') {
        print <<EOF
    label <virtual drive number> mydisk

    change the label for the specified virtual drive number. The
    label is truncated after TODO characters.

    Example:
    label 1 mydisk
    label 0 flex_09
EOF
    }
    elsif ($cmd eq 'export') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'import') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'dir') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'delete') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'link') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'fix') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'rdboot') {
        print <<EOF
    rdboot <virtual drive number>

    Read the boot sector from the specified virtual drive. Store it
    for use with the wrboot command.
EOF
    }
    elsif ($cmd eq 'wrboot') {
        print <<EOF
    wrboot <virtual drive number>

    A boot sector can be loaded using rdboot or rdbootfile. Write
    the most recently loaded boot sector to the specified virtual
    drive. After doing this, you will need to use the link command
    in order to make the disk bootable.
EOF
    }
    elsif ($cmd eq 'rdbootfile') {
        print <<EOF
    rdbootfile <file on host filesystem>

    Read a binary blob (required to be exactly 256 bytes in size) and
    store it for use with the wrboot command.
EOF
    }
    elsif ($cmd eq 'check') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'scrub') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'repair') {
        print <<EOF
TODO
EOF
    }
    else {
        # no more to say about info, help, exit (or any non-existent command)
        print <<EOF
    No additional help is available on that topic
EOF
    }
}


sub help_generic {
    print <<EOF

flex_vfs allows manipulation of up to 4 virtual drives, numbered 0 through 3.
Each drive can be associated with a file on the host filesystem. Files
can be copied between virtual drives or transferred between virtual drives
and the host filesystem. Virtual drives can be inspected and manipulated.

Commands are:

    mount      - associate disk image with virtual drive number
    clone      - make copy of virtual drive (optional format conversion)
    info       - report virtual drives currently mounted
    umount     - disconnect disk image from drive number
    new        - create new empty disk image (optional geometry specification)
    copy       - copy file(s) from one virtual drive to another
    label      - change disk label
    export     - copy file from virtual drive to local file system (optional format conversion)
    import     - copy file from local file system to virtual drive (optional format conversion)
    dir        - directory of virtual drive
    delete     - delete file(s) from virtual drive
    link       - patch boot sector on virtual drive
    fix        - perform low-level edit on virtual drive
    rdboot     - copy boot sector from virtual drive
    wrboot     - write boot sector to virtual drive
    rdbootfile - read boot sector from file on local file system
    check      - check integrity of virtual drive
    scrub      - null out deleted file names and unused sectors
    repair     - repair virtual drive
    exit       - unmount all mounted drives and leave flex_vfs
    quit       - synonym for exit
    help       - this is it.

Type help <command name> for more help.
EOF
}










#########------------
sub help_exit {
    print <<EOF

Virtual file system for FLEX disk images.

> new 0 fred.dsk t=45 s=90
> copy 1.temp.txt 2
> export 2.advent.c textconvert
> export 2.advent.c binconvert
> import 2.test.txt ../../hello.c textconvert
> import 3.file.cmd file.bin binconvert
> dir 1
> dir 2
> copy 1.*.cmd 2
> delete 1.fred.bin
> delete 2.*.bin
> link 1.flex.sys
> fix 1.flex.sys
> rdboot 1
> wrboot 2
> rdbootfile multicomp_flex_loader.bin
> check 1
> check 2
> exit
>





 Usage:

flex_disk_manip [-help] [INFILE <options>]

    -help              print usage information and terminate
    INFILE             name of a FLEX disk image file (usually .dsk)
    -info              perform integrity check and report information about the
                       image
    -dir               report names of all files contained in the image
    -insd              by default input files are in .dsk format. This specifies
                       that the input file is in SD file format (notes below)
    -out OUTFILE       write disk image out in .dsk file format
    -outsd OUTFILE     write disk image out in SD file format (notes below)
    -extract [name1 name2..] extract files from disk (notes below)
    -extractall        extract all files from disk
    -extractloader     extract FLEX loader (notes below)

SD File format

A FLEX disk image has a fixed sector size of 256 bytes. In order to transfer it to an SDCARD it
is convenient (though inefficient) to place each sector in the first half of a 512 byte block.
This has the effect of generating an output image that is exactly twice the size of the input
image.

For no particularly good reason (but maybe for integrity checking later) "-outsd" achieves this
by duplicating each 256 byte data chunk.

"-insd" performs the opposite check: for each 512 bytes in, it reports whether the first and
second half of each 512 byte block contain identical data or not.

Extracting files

If the "-extract" option is used, the remaining command-line parameters are assumed to be the
names of files in the disk image. Each file is extracted to the current directory as a file
with the same name as it had in the disk image.

The "-extractloader" option extracts track 0 sector 1 and saves it as "flex_loader.bin". For
a system disk this expected to contain the FLEX boot loader -- but note that this is target
system dependent as some target systems may boot straight from ROM with no need for this
intermediate bootstrap. Other systems may have a loader that extends beyond this one sector.
If this image is a valid FLEX boot loader it will be designed to load at address \$C100 and to
be executed from that address. The bytes at address \$C105, \$C106 specify the track and
sector at which the FLEX image is stored on the disk.

EOF
}

