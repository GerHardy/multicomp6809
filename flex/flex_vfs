#!/usr/bin/perl
#
# Manipulator for FLEX disk images. Designed to act as a virtual file system
# for disk analysis, extract, import, copy, creation, conversion.
#
# Mostly designed for interactive use but also allows limited non-interactive
# use.
#
# Neal Crook, July 2015.

# next: revamp dir to extract directory at mount time, a general-purpose file list filter
# and a directory lister
# next: arg checker for fs (File Specifier) and ufs (Unique File Specifier)
# next: re-pack and commit SIR
# next: make sure directory and sir are never dirty, otherwise have to trap ^C and
# any fatal error in order to avoid file corruption. It's just not worth it.
# next: label
# next: implement "then" as command separator and allow command-line and add to help.
# implement label link
# improve dir to allow wildcard
# then new copy delete check scrub
# finally import export repair
# maybe have commands extend (add n sectors) and truncate (remove n sectors)
# TODO: record inode so that we cannot double-mount a drive?
# TODO: add mixedcase toggle command

use strict;
no strict 'refs'; # CLI makes subroutine from command name.
use warnings;


# FLEX constants
#
# Tracks are numbered 0..n
# Sectors are numbered 1..n
#
# The .dsk image contains a linear sequence of sector-sized data.
# This program uses the word "block" to refer to the linear offset.
# For example, track=0, sector=1 is block 0.
# block <-> track/sector conversion is easy for the first track
# but requires knowledge of the system information record (SIR)
# in order to do conversions beyond the first track.
my %flx;
$flx{BYTES_SECTOR} = 256;
#TODO not using these. Represent as a triplet and then use them?
$flx{SIR_BLK} = 2; # Track=0 Sector=3
$flx{LDR_BLK} = 0; # Track=0 Sector=1
$flx{DIR_BLK} = 4; # Track=0 Sector=5



# Data structure
# $dsk[0..3]
# $dsk[n]->{mounted} boolean
# $dsk[n]->{handle} file handle
# $dsk[n]->{bytes_blk} 256 for dsk file, 512 for img file
# $dsk[n]->{blks} number of blocks
# $dsk[n]->{filename} file name by which file was accessed
# filled in by reading SIR when disk was mounted
# $dsk[n]->{sir}->{data} array of data
# $dsk[n]->{sir}->{NAME} decoded fields of sir.
# $dsk[n]->{sir}->{NUM}

my @dsk;

# Boot sector. Binary string. Undefined if not loaded.
my $boot;


# Command-line interpreter
while (1) {
    print "flex_vfs: ";
    my $cmd = <>;
    chomp $cmd;
    next if ($cmd eq "");
    my @bits = split " ", $cmd;
    my $sub = "cmd_$bits[0]";
    if (defined(&{$sub})) {
        shift @bits;
        &{$sub}(@bits);
    }
    else {
        print "ERROR: no command $bits[0]\n";
    }
}

#################################################################
#################################################################
## Commands

sub cmd_mount {
    my ($drive, $file, $format) = arg_check('v h of', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is already mounted.\n";
        return;
    }

    if (open $dsk[$drive]->{handle}, '+<', $file) {
        # so far so good
        $dsk[$drive]->{filename} = $file;
        $dsk[$drive]->{bytes_blk} = $format eq 'dsk' ? 256 : 512;

        my $sir = rd_dts($drive, 0, 3);
        my @sir = unpack("C*", $sir);
        $dsk[$drive]->{sir}->{data} = \@sir;
        decode_sir($drive);

        # size the disk image
        my $tmp;
        $dsk[$drive]->{blks} = 0;
        seek $dsk[$drive]->{handle}, 0, 0;
        while (my $actual = read $dsk[$drive]->{handle}, $tmp, $dsk[$drive]->{bytes_blk}) {
            if ($actual == $dsk[$drive]->{bytes_blk}) {
                $dsk[$drive]->{blks} = $dsk[$drive]->{blks} + 1;
            }
            else {
                print "ERROR image is not a multiple of $dsk[$drive]->{bytes_blk}. Mount aborted.\n";
                return;
            }
        }

        # is the sir believable?
        if (($dsk[$drive]->{sir}->{data}->[0] != 0) or ($dsk[$drive]->{sir}->{data}->[1] != 0)) {
            print "ERROR first two bytes of SIR were non-zero. Mount aborted.\n";
            return;
        }

        # is the block count consistent with track/sector count
        if ($dsk[$drive]->{blks} != ($dsk[$drive]->{sir}->{MAX_T} + 1) * $dsk[$drive]->{sir}->{MAX_S}) {
            printf "ERROR block count (%d) is inconsistent with track range (0-%d) and sector range (1-%d). Mount aborted.\n",
            $dsk[$drive]->{blks},
            $dsk[$drive]->{sir}->{MAX_T}, $dsk[$drive]->{sir}->{MAX_S};
            return;
        }

        # finally
        $dsk[$drive]->{mounted} = 1;
    }
    else {
        # Unlikely - it opened OK in arg_check
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_clone {
    my ($drive, $file, $format) = arg_check('v nh of', @_);
    return unless defined($drive);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is not mounted.\n";
        return;
    }

    my $bb_in = $dsk[$drive]->{bytes_blk};
    my $bb_out = $format eq 'dsk' ? 256 : 512;

    if (open my $handle, '>', $file) {
        seek $dsk[$drive]->{handle}, 0, 0;
        my $data;
        for my $blk (1..$dsk[$drive]->{blks}) {
            # read a block
            my $actual = read $dsk[$drive]->{handle}, $data, $bb_in;
            if ($actual == $bb_in) {
                if ($bb_in == $bb_out) {
                    print $handle $data;
                }
                elsif ($bb_in < $bb_out) {
                    print $handle $data;
                    print $handle $data;
                }
                else {
                    my $half = substr $data, $bb_out, $bb_out;
                    print $handle $half;
                }
            }
            else {
                close $handle;
                die "FATAL internal error - failed to read data\n";
            }
        }
        close $handle;
    }
    else {
        # Unlikely - it opened OK in arg_check
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_info {
    for my $drive (0..3) {
        print "Drive $drive: ";
        if ($dsk[$drive]->{mounted}) {
            print "Host file:    $dsk[$drive]->{filename}\n";
            describe_sir($drive);
        }
        else {
            print "not mounted\n";
        }
    }
}


sub cmd_umount {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    # silently ignored if this drive number is not currently in use.
    if ($dsk[$drive]->{mounted}) {
        close $dsk[$drive]->{handle};
        $dsk[$drive]->{mounted} = 0;
    }
}


sub cmd_new {
    print "new TODO - not yet implemented\n";
}


sub cmd_copy {
    print "copy TODO - not yet implemented\n";
}


sub cmd_label {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
# TODO
# TODO update in {sir} and then flush to disk? 
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_export {
    print "export TODO - not yet implemented\n";
}


sub cmd_import {
    print "import TODO - not yet implemented\n";
}


# TODO might have different invocations. For now just handle the first
# dir 1
# dir 1.fred.bin
# dir 1.*.bin
sub cmd_dir {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    # first sector of directory.
    # Directory format is described in FLEXAPG
    my $trk = 0;
    my $sct = 5;

    # TODO HACK - probably want to abstract this in order to deal with wildcards and to
    # allow us to eg find parameters for a specific file (eg for LINK command).
    # Do this at Mount time and store it in $dsk, then change dir to filter and print
    # the filtered results. Write a general-purpose filter for use elsewhere.
    my @dir;

    while (($trk != 0) or ($sct != 0)) {
        # process a directory sector
        my $data = rd_dts($drive, $trk, $sct);
        my @data = unpack("C*", $data);

        my $offset = 16;
        foreach my $entry(0..9) {
            my %d;

            # first byte of filename is 0 if it has never been used
            # or has bit 7 set if it has been deleted.
            my $nstart = 4 -4+$offset+($entry*24);
            my $first = ord substr($data, $nstart, 1);
            next if (($first == 0) || ($first & 0x80));

# TODO convert to ONLY use @data instead
            # the name can be null-terminated, which is non-printing but tidiest to remove them
            my $name = substr($data, $nstart, 8);
            $name =~ /(^[a-zA-Z0-9\-\_]+)/;
            $d{NAME} = $1;

            # likewise the extension
            my $ext = substr($data, $nstart+8, 3);
            $ext =~ /(^[a-zA-Z]+)/;
            $d{EXT} = $1;

            $d{ATTR}    = $data[15-4+$offset+($entry*24)];
            $d{FIRST_T} = $data[17-4+$offset+($entry*24)];
            $d{FIRST_S} = $data[18-4+$offset+($entry*24)];
            $d{LAST_T}  = $data[19-4+$offset+($entry*24)];
            $d{LAST_S}  = $data[20-4+$offset+($entry*24)];
            $d{SIZE}    = 256 * $data[21+0-4+$offset+($entry*24)] +
                                $data[21+1-4+$offset+($entry*24)];
            $d{FSM}     = $data[23-4+$offset+($entry*24)];
            $d{DATE_M}  = $data[25+0-4+$offset+($entry*24)];
            $d{DATE_D}  = $data[25+1-4+$offset+($entry*24)];
            $d{DATE_Y}  = $data[25+2-4+$offset+($entry*24)] %100; # Y2K fixup

            push @dir,\%d;
        }
        # next
        $trk = $data[0];
        $sct = $data[1];
    }

    # TODO hack now print it?
    print "               NAME ATTR START     END          SIZE    DATE\n";
    foreach my $i (@dir) {
        # attributes
        my $attr = "     ";
        if ($i->{ATTR} & 0x80) {substr($attr, 0, 1) = "W"};
        if ($i->{ATTR} & 0x40) {substr($attr, 1, 1) = "D"};
        if ($i->{ATTR} & 0x20) {substr($attr, 2, 1) = "R"};
        if ($i->{ATTR} & 0x10) {substr($attr, 3, 1) = "C"};
        if ($i->{FSM} != 0   ) {substr($attr, 4, 1) = "r"};
        printf "% 15s.%-3s $attr t%02d,s%02d - t%02d,s%02d %4d sectors %02d-%02d-%02d\n", $i->{NAME}, $i->{EXT}, $i->{FIRST_T}, $i->{FIRST_S}, $i->{LAST_T}, $i->{LAST_S}, $i->{SIZE}, $i->{DATE_M}, $i->{DATE_D}, $i->{DATE_Y};
    }

}


sub cmd_delete {
    print "delete TODO - not yet implemented\n";
}


sub cmd_link {
    print "link TODO - not yet implemented\n";
}


sub cmd_fix {
    print "fix TODO - not yet implemented\n";
}


sub cmd_rdboot {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        my $data = rd_dts($drive, 0, 1);
        if (defined $data) {
            $boot = $data;
        }
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_wrboot {
    my ($drive) = arg_check('v', @_);
    return unless defined($drive);

    if (defined $boot) {
        if ($dsk[$drive]->{mounted}) {
            wr_dts($drive, 0, 1, $boot);
        }
        else {
            print "ERROR virtual drive $drive is not mounted\n";
        }
    }
    else {
        print "ERROR boot sector not loaded. Use rdboot or rdbootfile\n";
    }
}


sub cmd_rdbootfile {
    my $file = $_[0];
    if (open IN, $file) {
        my $data;
        my $got = read IN, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            my $tmp;
            $got = read IN, $tmp, 1;
            if ($got == 0) {
                # it's all good.
                $boot = $data;
            }
            else {
                print "ERROR too much data - expected exactly $flx{BYTES_SECTOR} bytes\n";
            }
        }
        else {
            print "ERROR not enough data - expected $flx{BYTES_SECTOR} bytes\n";
        }
        close IN;
    }
    else {
        print "ERROR could not open $file\n";
    }
}


sub cmd_check {
    print "check TODO - not yet implemented\n";
}


sub cmd_scrub {
    print "scrub TODO - not yet implemented\n";
}


sub cmd_repair {
    print "repair TODO - not yet implemented\n";
}


sub cmd_quit {
    cmd_exit();
}


sub cmd_exit {
    cmd_umount(0);
    cmd_umount(1);
    cmd_umount(2);
    cmd_umount(3);
    exit;
}


sub cmd_help {
    my $help_for = $_[0];
    if (defined $help_for) {
        help_for($help_for);
    }
    else {
        help_generic();
    }
}


#################################################################
#################################################################
# Subroutines

# string of expected argument formats, followed by argument list
# prints error message for any mismatch.
# returns args if all OK.
# otherwise returns nothing.
# "v a b", ("arg1", "arg2", "arg3", "arg4)
# argument formats are:
# v - virtual drive number
# h - existing file in host filesystem
# nh - file in host filesystem (may or may not exist)
# of - optional file format: dsk or img, also inferred from h
sub arg_check {
    my @expected = split " ",(shift @_);
    my %format;
    my $i = 0;
    foreach my $f (@expected) {
        # allows random access later on..
        $format{$f} = $i;

        if ($f eq 'v') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected virtual drive number\n";
                return;
            }
            if (($_[$i] ne "0") and ($_[$i] ne "1") and
                ($_[$i] ne "2") and($_[$i] ne "3")) {
                print "ERROR $_[$i] is not a legal virtual drive number\n";
                return;
            }
        }
        elsif ($f eq 'h') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            if (open my $tmp, '+<', $_[$i]) {
                # all good
                close $tmp;
            }
            else {
                print "ERROR could not open $_[$i]\n";
                return;
            }
        }
        elsif ($f eq 'nh') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            # file may not exist so open for output
            if (open my $tmp, '>', $_[$i]) {
                # all good
                close $tmp;
                # make 'nh' look equivalent to 'n' coz we may need the extension
                $format{h} = $i;
            }
            else {
                print "ERROR could not open $_[$i]\n";
                return;
            }
        }
        elsif ($f eq 'of') {
            # optional format. If present, takes precedence and must be img or dsk
            # If absent, inferred from file extension of {h} argument. Incoming
            # arguments changed to declare the format.

            if ((defined $_[$i]) && (($_[$i] eq 'img') or ($_[$i] eq 'dsk'))) {
                # explicit format takes priority. Nothing more to do.
            }
            else {
                # extract extension from filename elsewhere in argument list
                my @ext = split /\./, $_[$format{h}];
                if ((defined $ext[-1]) && (($ext[-1] eq 'img') or ($ext[-1] eq 'dsk'))) {
                    # change incoming argument so it's always present/valid
                    $_[$i] = $ext[-1];
                }
                else {
                    print "ERROR could not infer format. Specify dsk or img\n";
                    return;
                }
            }
        }
        else {
            die "FATAL internal error - unknown format $f\n";
        }
        $i = $i + 1;
    }
    return @_;
}


# read a sector, return data as a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and read 1st copy of the data
sub rd_dts {
    my ($drive, $trk, $sct) = @_;
    my $seek;
    my $data;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        if ($trk > $dsk[$drive]->{sir}->{MAX_T}) {
            die "FATAL ERROR track $trk is out of range";
        }
        if ($sct > $dsk[$drive]->{sir}->{MAX_S}) {
            die "FATAL ERROR sector $sct is out of range";
        }

        $seek = (($sct - 1) + ($trk * $dsk[$drive]->{sir}->{MAX_S})) * $dsk[$drive]->{bytes_blk};
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $got = read $dsk[$drive]->{handle}, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            return $data;
        }
        else {
            die "Could not read $flx{BYTES_SECTOR} bytes at offset $seek on drive $drive";
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}


# write a sector, incoming data is a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and write 2 copies of the data
sub wr_dts {
    my ($drive, $trk, $sct, $data) = @_;
    my $seek;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        if ($trk > $dsk[$drive]->{sir}->{MAX_T}) {
            die "FATAL ERROR track $trk is out of range";
        }
        if ($sct > $dsk[$drive]->{sir}->{MAX_S}) {
            die "FATAL ERROR sector $sct is out of range";
        }

        $seek = (($sct - 1) + ($trk * $dsk[$drive]->{sir}->{MAX_S})) * $dsk[$drive]->{bytes_blk};
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $fh = $dsk[$drive]->{handle};
        print $fh $data;
        if ($dsk[$drive]->{bytes_blk} != $flx{BYTES_SECTOR}) {
            # 2nd copy
            print $fh $data;
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}

# decode bytes of the sir into a data structure that makes it
# easy to access
sub decode_sir {
    my $drive = $_[0];

    my $sir = $dsk[$drive]->{sir}->{data};

    # SIR format is described in section 9.1.5 of the 6809FAG
    $dsk[$drive]->{sir}->{LNK}     = 256 * $sir->[0] + $sir->[1];
    my $name = '';
    for my $i (16..16+11-1) {
        $name = $name . chr $dsk[$drive]->{sir}->{data}->[$i];
    }
    $dsk[$drive]->{sir}->{NAME}    = $name;
    $dsk[$drive]->{sir}->{NUM}     = 256 * $sir->[27] + $sir->[28];
    $dsk[$drive]->{sir}->{FIRST_T} = $sir->[29];
    $dsk[$drive]->{sir}->{FIRST_S} = $sir->[30];
    $dsk[$drive]->{sir}->{LAST_T}  = $sir->[31];
    $dsk[$drive]->{sir}->{LAST_S}  = $sir->[32];
    $dsk[$drive]->{sir}->{FREE}    = 256 * $sir->[33] + $sir->[34];
    $dsk[$drive]->{sir}->{DATE_M}  = $sir->[35];
    $dsk[$drive]->{sir}->{DATE_D}  = $sir->[36];
    $dsk[$drive]->{sir}->{DATE_Y}  = $sir->[37] %100; # Y2K fixup
    $dsk[$drive]->{sir}->{MAX_T}   = $sir->[38];
    $dsk[$drive]->{sir}->{MAX_S}   = $sir->[39];

    # need to make a guess now so that the directory can be inspected. Verify the guess
    # later on and confess if we got it wrong.
    $dsk[$drive]->{sir}->{T1_OFFSET} = $dsk[$drive]->{sir}->{MAX_S};
}

# Dump the SIR in human-readable format
sub describe_sir {
    my $drive = $_[0];
    my $i = "        ";

    printf "$i Image size:   %d blocks (%d bytes)\n",
    $dsk[$drive]->{blks}, $dsk[$drive]->{blks} * $dsk[$drive]->{bytes_blk};
# TODO
#        printf "%d blocks with data first/second half mismatches\n", $dsk[$drive]->{sir}->{SDMISMATCH};

    printf "$i Disk name:   %12s\n", $dsk[$drive]->{sir}->{NAME};
    printf "$i Disk number:  %d\n",  $dsk[$drive]->{sir}->{NUM};
    printf "$i Disk date:    %02d-%02d-%02d\n", $dsk[$drive]->{sir}->{DATE_M},
    $dsk[$drive]->{sir}->{DATE_D}, $dsk[$drive]->{sir}->{DATE_Y};
    printf "$i Free sectors: %d. Free chain t%02d,s%02d - t%02d,s%02d\n",
    $dsk[$drive]->{sir}->{FREE},
    $dsk[$drive]->{sir}->{FIRST_T}, $dsk[$drive]->{sir}->{FIRST_S},
    $dsk[$drive]->{sir}->{LAST_T}, $dsk[$drive]->{sir}->{LAST_S};
    printf "$i Range:        t00-t%02s, s01-s%02s\n",
    $dsk[$drive]->{sir}->{MAX_T}, $dsk[$drive]->{sir}->{MAX_S};
    printf "$i Trk0 sectors: $dsk[$drive]->{sir}->{T1_OFFSET}\n";
}



# return true if $drive is 0-3, false otherwise.
# TODO may never be called now?
sub legal_drive {
    my $drive = $_[0];
    return ((defined $drive) && (($drive eq '0') or ($drive eq '1') or ($drive eq '2') or ($drive eq '3')));
}

# if $format is non-blank it must be img or dsk.
# if $format is blank infer format from extension of $file
# return format or '' if unknown.
# TODO may never be called now?
sub infer_format {
    my ($file, $format) = @_;

    if ((defined $format) && (($format eq 'img') or ($format eq 'dsk'))) {
        # explicit format takes priority
        return $format;
    }
    else {
        my @ext = split /\./, $file;
        print "Got $file $ext[0] $ext[1] $ext[-1]\n";
        if ((defined $ext[-1]) && (($ext[-1] eq 'img') or ($ext[-1] eq 'dsk'))) {
            return $ext[-1];
        }
    }
    return '';
}


sub help_for {
    my $cmd = $_[0];
    if ($cmd eq 'mount') {
        print <<EOF
    mount <virtual drive number> <file on host filesystem> [format]

    Associate a file on the host filesystem with a virtual drive number.

    Virtual drive number is 0,1,2 or 3.

    Legal formats are dsk and img (use "help formats" for
    more information).

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    Examples:
    mount 1 ../../foo.dsk
    mount 0 advent.dsk
    mount 2 system.img
    mount 0 flex09.zzz img
    mount 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'clone') {
        print <<EOF
    clone <virtual drive number> <file on host filesystem> [format]

    Make a copy of a virtual drive as a file on the host filesystem

    Virtual drive number is 0,1,2 or 3.
    Legal formats are "dsk" (256 bytes per sector) and "img" (256
    bytes per sector but doubled, on a 512-byte boundary)

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    If the format is different from the format of the virtual drive,
    format conversion will be performed.

    Examples:
    clone 1 ../../foo.dsk
    clone 0 advent.dsk
    clone 2 system.img
    clone 0 flex09.zzz img
    clone 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'umount') {
        print <<EOF
    umount <virtual drive number>

    Close file associated with virtual drive number and make that virtual
    drive number available for reuse.

    Examples:
    umount 0
    umount 2
EOF
    }
    elsif ($cmd eq 'new') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'copy') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'label') {
        print <<EOF
    label <virtual drive number> mydisk

    change the label for the specified virtual drive number. The
    label is truncated after TODO characters.

    Example:
    label 1 mydisk
    label 0 flex_09
EOF
    }
    elsif ($cmd eq 'export') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'import') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'dir') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'delete') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'link') {
        print <<EOF
    link <full file specifier>

    Patch the boot sector of the disk holding the specified
    file (usually FLEX.SYS) so that a subsequent boot of the
    system will load and start the specified file.

    Example:
    link 1.FLEX.SYS

    Background:
    use "help wrboot" for background on the Flex boot sector.
EOF
    }
    elsif ($cmd eq 'fix') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'rdboot') {
        print <<EOF
    rdboot <virtual drive number>

    Read the boot sector from the specified virtual drive. It is
    then available for use by the wrboot command.
EOF
    }
    elsif ($cmd eq 'wrboot') {
        print <<EOF
    wrboot <virtual drive number>

    Write the current boot loader (read using the rdboot or
    rdbootfile commands) to the boot sector of the specified
    virtual drive. After doing this, you will need to use the
    link command in order to make the disk bootable.

    Examples:
    rdboot 2
    wrboot 1
    link 1.FLEX.SYS

    Background:
    Track 0 sector 1 of a Flex disk is designated as the Flex boot
    sector, and usually holds the Flex boot loader -- this is
    target system dependent as some systems boot straight from ROM
    with no need for this intermediate bootstrap. Other systems may
    have a loader that extends beyond this one sector. A Flex boot
    loader is designed to load at address \$C100 and to be executed
    from that address. The bytes at address \$C105, \$C106 specify
    the track and sector at which the Flex image (usually named
    FLEX.SYS) is stored on the disk.

    The Flex LINK command (and the flex_vfs link command) locate
    a named file (eg FLEX.SYS) and patch the boot sector with the
    start track/sector of that image. This makes the function of
    the boot loader simpler.
EOF
    }
    elsif ($cmd eq 'rdbootfile') {
        print <<EOF
    rdbootfile <file on host filesystem>

    Read a binary blob (required to be exactly 256 bytes in size). It
    is then available for use by the wrboot command.
EOF
    }
    elsif ($cmd eq 'check') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'scrub') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'repair') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'formats') {
        print <<EOF
    Flex disks use a fixed sector size of 256 bytes, but varying
    geometries (the sector count and head count). Since the geometry
    is described within the SIR on the 3rd sector of the disk, it's
    possible to write a disk driver that can read the geometry from
    the SIR and then access any track/sector correctly. Thanks to
    this far-sight on behalf of the Flex designers, a Flex disk
    image can simply be represented as a sequence of 256-byte
    blocks and is "self-describing" thanks to its SIR. The normal
    file extension used for a Flex disk in this format is .dsk.

    In order to use an SDcard as a virtual floppy disk, it's
    necessary to translate between the track/sector number (which
    the Flex disk routines understand) and a linear block number
    (which the SDcard addressing understands). Also, the block
    size on an SDcard is 512 bytes.

    It would be possible to store 2 Flex sectors in each SDcard
    block but it is simpler (though inefficient) to store each
    sector in the first half of a 512 byte block. This has the
    effect of generating an image that is exactly twice the size
    of the .dsk file. In flex_vfs, the file extension used for
    this double-sized file is .img.

    flex_vfs can mount .img and .dsk files and can convert from
    one to the other using the clone command.

    For no particularly good reason (but maybe for integrity
    checking later) flex_vfs stores 2 copies of a Flex sector in
    each SDcard block. On reads, the first copy is used.
EOF
    }
    else {
        # no more to say about info, help, exit (or any non-existent command)
        print <<EOF
    No additional help is available on that topic
EOF
    }
}


sub help_generic {
    print <<EOF

flex_vfs allows manipulation of up to 4 virtual drives, numbered 0 through 3.
Each drive can be associated with a file on the host filesystem. Files
can be copied between virtual drives or transferred between virtual drives
and the host filesystem. Virtual drives can be inspected and manipulated.

Commands are:

    mount      - associate disk image with virtual drive number
    clone      - make copy of virtual drive (optional format conversion)
    info       - report virtual drives currently mounted
    umount     - disconnect disk image from drive number
    new        - create new empty disk image (optional geometry specification)
    copy       - copy file(s) from one virtual drive to another
    label      - change disk label
    export     - copy file from virtual drive to local file system (optional format conversion)
    import     - copy file from local file system to virtual drive (optional format conversion)
    dir        - directory of virtual drive
    delete     - delete file(s) from virtual drive
    link       - patch boot sector on virtual drive
    fix        - perform low-level edit on virtual drive
    rdboot     - copy boot sector from virtual drive
    wrboot     - write boot sector to virtual drive
    rdbootfile - read boot sector from file on local file system
    check      - check integrity of virtual drive
    scrub      - null out deleted file names and unused sectors
    repair     - repair virtual drive
    exit       - unmount all mounted drives and leave flex_vfs
    quit       - synonym for exit
    help       - this is it.

Type help <command name> for more help.
EOF
}




#########------------
sub help_exit {
    print <<EOF

Virtual file system for FLEX disk images.

> new 0 fred.dsk t=45 s=90
> copy 1.temp.txt 2
> export 2.advent.c textconvert
> export 2.advent.c binconvert
> import 2.test.txt ../../hello.c textconvert
> import 3.file.cmd file.bin binconvert
> dir 1
> dir 2
> copy 1.*.cmd 2
> delete 1.fred.bin
> delete 2.*.bin
> fix 1.flex.sys
> rdboot 1
> wrboot 2
> rdbootfile multicomp_flex_loader.bin
> check 1
> check 2
> exit
>

EOF
}

