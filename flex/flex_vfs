#!/usr/bin/perl
#
# Manipulator for FLEX disk images. Designed to act as a virtual file system
# for disk analysis, extract, import, copy, creation, conversion.
#
# Mostly designed for interactive use but also allows limited non-interactive
# use.
#
# Neal Crook, July 2015.

# next: implement cp_files rm_files
# add deleted sectors to the END of the free list.
# next: make sure directory and sir are never dirty, otherwise have to trap ^C and
# any fatal error in order to avoid file corruption. It's just not worth it.
# next: label
# next: implement "then" as command separator and allow command-line and add to help.
# then new copy delete check scrub
# finally import export repair
# TODO: record inode so that we cannot double-mount a drive?
# TODO: it is NOT legal to have a null file name. It is legal to have a null extension?
# TODO: add optional y/n arg to delete.
# FUTURE: DATE command, RENAME command, mixedcase-toggle command
# FUTURE: TRUNCATE (remove sectors) and EXTEND (add sectors) commands
# FUTURE: allow target of copy to be unique fs rather than simply drive name (ie copy
# file with different name)

use strict;
no strict 'refs'; # CLI makes subroutine from command name.
use warnings;


# FLEX constants
#
# Tracks are numbered 0..n
# Sectors are numbered 1..n
#
# The .dsk image contains a linear sequence of sector-sized data.
# This program uses the word "block" to refer to the linear offset.
# For example, track=0, sector=1 is block 0.
# block <-> track/sector conversion is easy for the first track
# but requires knowledge of the system information record (SIR)
# in order to do conversions beyond the first track.
my %flx;
$flx{BYTES_SECTOR} = 256;
#TODO not using these. Represent as a triplet and then use them?
$flx{SIR_BLK} = 2; # Track=0 Sector=3
$flx{LDR_BLK} = 0; # Track=0 Sector=1
$flx{DIR_BLK} = 4; # Track=0 Sector=5



# Data structure
# $dsk[0..3]
# $dsk[n]->{mounted} boolean
# $dsk[n]->{handle} file handle
# $dsk[n]->{bytes_blk} 256 for dsk file, 512 for img file
# $dsk[n]->{blks} number of blocks
# $dsk[n]->{filename} file name by which file was accessed
# filled in by rd_sir when disk was mounted:
# $dsk[n]->{sir}->{data} array of data
# $dsk[n]->{sir}->{NAME} decoded fields of sir.
# $dsk[n]->{sir}->{NUM}
# filled in by rd_dir when disk was mounted:
# $dsk[n]->{dir}->[n]->{NAME} array of directory entries
# $dsk[n]->{dir}->[n]->{EXT} etc.

my @dsk;

# Boot sector. Binary string. Undefined if not loaded.
my $boot;


# Command-line interpreter
while (1) {
    print "flex_vfs: ";
    my $cmd = <>;
    chomp $cmd;
    next if ($cmd eq "");
    my @bits = split " ", $cmd;
    my $sub = "cmd_$bits[0]";
    if (defined(&{$sub})) {
        shift @bits;
        &{$sub}(@bits);
    }
    else {
        print "ERROR: no command $bits[0]\n";
    }
}

#################################################################
#################################################################
## Commands

sub cmd_mount {
    my ($drive, $file, $format) = check_arg('v h of', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is already mounted.\n";
        return;
    }

    if (open $dsk[$drive]->{handle}, '+<', $file) {
        # so far so good
        $dsk[$drive]->{filename} = $file;
        $dsk[$drive]->{bytes_blk} = $format eq 'dsk' ? 256 : 512;

        my $sir = rd_dts($drive, 0, 3);
        my @sir = unpack("C*", $sir);
        $dsk[$drive]->{sir}->{data} = \@sir;
        rd_sir($drive);

        # size the disk image
        my $tmp;
        $dsk[$drive]->{blks} = 0;
        seek $dsk[$drive]->{handle}, 0, 0;
        while (my $actual = read $dsk[$drive]->{handle}, $tmp, $dsk[$drive]->{bytes_blk}) {
            if ($actual == $dsk[$drive]->{bytes_blk}) {
                $dsk[$drive]->{blks} = $dsk[$drive]->{blks} + 1;
            }
            else {
                print "ERROR image is not a multiple of $dsk[$drive]->{bytes_blk}. Mount aborted.\n";
                return;
            }
        }

        # is the sir believable?
        if (($dsk[$drive]->{sir}->{data}->[0] != 0) or ($dsk[$drive]->{sir}->{data}->[1] != 0)) {
            print "ERROR first two bytes of SIR were non-zero. Mount aborted.\n";
            return;
        }

        # is the block count consistent with track/sector count
        if ($dsk[$drive]->{blks} != ($dsk[$drive]->{sir}->{MAX_T} + 1) * $dsk[$drive]->{sir}->{MAX_S}) {
            printf "ERROR block count (%d) is inconsistent with track range (0-%d) and sector range (1-%d). Mount aborted.\n",
            $dsk[$drive]->{blks},
            $dsk[$drive]->{sir}->{MAX_T}, $dsk[$drive]->{sir}->{MAX_S};
            return;
        }

        # cache it for easy access
        rd_dir($drive);

        # finally
        $dsk[$drive]->{mounted} = 1;
    }
    else {
        # Unlikely - it opened OK in check_arg
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_clone {
    my ($drive, $file, $format) = check_arg('v nh of', @_);
    return unless defined($drive);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is not mounted.\n";
        return;
    }

    my $bb_in = $dsk[$drive]->{bytes_blk};
    my $bb_out = $format eq 'dsk' ? 256 : 512;

    if (open my $handle, '>', $file) {
        seek $dsk[$drive]->{handle}, 0, 0;
        my $data;
        for my $blk (1..$dsk[$drive]->{blks}) {
            # read a block
            my $actual = read $dsk[$drive]->{handle}, $data, $bb_in;
            if ($actual == $bb_in) {
                if ($bb_in == $bb_out) {
                    print $handle $data;
                }
                elsif ($bb_in < $bb_out) {
                    print $handle $data;
                    print $handle $data;
                }
                else {
                    my $half = substr $data, $bb_out, $bb_out;
                    print $handle $half;
                }
            }
            else {
                close $handle;
                die "FATAL internal error - failed to read data\n";
            }
        }
        close $handle;
    }
    else {
        # Unlikely - it opened OK in check_arg
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_info {
    for my $drive (0..3) {
        print "Drive $drive: ";
        if ($dsk[$drive]->{mounted}) {
            print "Host file:    $dsk[$drive]->{filename}\n";
            describe_sir($drive);
        }
        else {
            print "not mounted\n";
        }
    }
}


sub cmd_umount {
    my ($drive) = check_arg('v', @_);
    return unless defined($drive);

    # silently ignored if this drive number is not currently in use.
    if ($dsk[$drive]->{mounted}) {
        close $dsk[$drive]->{handle};
        $dsk[$drive]->{mounted} = 0;
    }
}


sub cmd_new {
    print "new TODO - not yet implemented\n";
}


sub cmd_copy {
    my ($fs, $dst) = check_arg('fs v', @_);
    return unless defined($fs);

    my ($src,$file,$ext) = split /\./, $fs;

    if (not $dsk[$src]->{mounted}) {
        print "ERROR source drive $src is not mounted\n";
        return;
    }
    if (not $dsk[$dst]->{mounted}) {
        print "ERROR destination drive $dst is not mounted\n";
        return;
    }
    if ($src == $dst) {
        print "ERROR cannot copy to the same drive\n";
        return;
    }

    my $cp_match = filter_dir($src,$file,$ext);
    # which of those names already in use at the destination?
    my $rm_match = exact_match_dir($src,$cp_match,$dst);

    # is there enough space for the copy?
    my $dst_free = $dsk[$dst]->{sir}->{FREE} + sectors($dst, $rm_match);
    if ($dst_free < sectors($src, $cp_match)) {
        print "ERROR insufficient space for copy\n";
        return;
    }

    rm_files($dst, $rm_match);
    rd_dir($dst);
    cp_files($src, $cp_match, $dst);
    rd_dir($dst);
}


sub cmd_label {
    my ($drive) = check_arg('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
# TODO
# TODO update in {sir} and then flush to disk?
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_export {
    print "export TODO - not yet implemented\n";
}


sub cmd_import {
    print "import TODO - not yet implemented\n";
}


# directory is in $dsk - just filter/print it here.
# All of these are legal:
# dir 1    dir 1.fred.bin   dir 1.*.bin   dir 2.fr*.*
# the first (just the drive specified) is a special case and
# is converted (by check_arg) into 1.*.* so that can be treated
# in the same way as the other forms.
sub cmd_dir {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($drive,$file,$ext) = split /\./, $fs;

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext);

    print "               NAME  ATTR START     END          SIZE    DATE\n";

    foreach my $i (@{$match}) {
        my $j = $dsk[$drive]->{dir}->[$i];
        # attributes
        my $attr = "     ";
        if ($j->{ATTR} & 0x80) {substr($attr, 0, 1) = "W"};
        if ($j->{ATTR} & 0x40) {substr($attr, 1, 1) = "D"};
        if ($j->{ATTR} & 0x20) {substr($attr, 2, 1) = "R"};
        if ($j->{ATTR} & 0x10) {substr($attr, 3, 1) = "C"};
        if ($j->{FSM} != 0   ) {substr($attr, 4, 1) = "r"};
        printf "% 15s.%-3s $attr t%02d,s%02d - t%02d,s%02d %4d sectors %02d-%02d-%02d\n",
        $j->{NAME}, $j->{EXT},
        $j->{FIRST_T}, $j->{FIRST_S}, $j->{LAST_T}, $j->{LAST_S},
        $j->{SIZE}, $j->{DATE_M}, $j->{DATE_D}, $j->{DATE_Y};
    }
}


sub cmd_delete {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($drive,$file,$ext) = split /\./, $fs;

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext);

    printf "INFO %d files match $drive.$file.$ext\n", scalar @$match;

    rm_files($drive, $match);
    # directory copy is out-of-date now so revise it
    rd_dir($drive);
}


sub cmd_link {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($drive,$file,$ext) = split /\./, $fs;

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext);

    if (scalar @$match == 0) {
        print "ERROR no file found matching $drive.$file.$ext\n";
    }
    elsif (scalar @$match > 1) {
        print "ERROR multiple files found matching $drive.$file.$ext\n";
    }
    else {
        my $data = rd_dts($drive, 0, 1);
        my @data = unpack("C*", $data);
        $data[5] = $dsk[$drive]->{dir}->[$match->[0]]->{FIRST_T};
        $data[6] = $dsk[$drive]->{dir}->[$match->[0]]->{FIRST_S};
        wr_dts($drive, 0, 1, pack("C*", @data));
    }
}


sub cmd_fix {
    print "fix TODO - not yet implemented\n";
}


sub cmd_rdboot {
    my ($drive) = check_arg('v', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        my $data = rd_dts($drive, 0, 1);
        if (defined $data) {
            $boot = $data;
        }
    }
    else {
        print "ERROR virtual drive $drive is not mounted\n";
    }
}


sub cmd_wrboot {
    my ($drive) = check_arg('v', @_);
    return unless defined($drive);

    if (defined $boot) {
        if ($dsk[$drive]->{mounted}) {
            wr_dts($drive, 0, 1, $boot);
        }
        else {
            print "ERROR virtual drive $drive is not mounted\n";
        }
    }
    else {
        print "ERROR boot sector not loaded. Use rdboot or rdbootfile\n";
    }
}


sub cmd_rdbootfile {
    my $file = $_[0];
    if (open IN, $file) {
        my $data;
        my $got = read IN, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            my $tmp;
            $got = read IN, $tmp, 1;
            if ($got == 0) {
                # it's all good.
                $boot = $data;
            }
            else {
                print "ERROR too much data - expected exactly $flx{BYTES_SECTOR} bytes\n";
            }
        }
        else {
            print "ERROR not enough data - expected $flx{BYTES_SECTOR} bytes\n";
        }
        close IN;
    }
    else {
        print "ERROR could not open $file\n";
    }
}


sub cmd_check {
    print "check TODO - not yet implemented\n";
}


sub cmd_scrub {
    print "scrub TODO - not yet implemented\n";
}


sub cmd_repair {
    print "repair TODO - not yet implemented\n";
}


sub cmd_quit {
    cmd_exit();
}


sub cmd_exit {
    cmd_umount(0);
    cmd_umount(1);
    cmd_umount(2);
    cmd_umount(3);
    exit;
}


sub cmd_help {
    my $help_for = $_[0];
    if (defined $help_for) {
        help_for($help_for);
    }
    else {
        help_generic();
    }
}


#################################################################
#################################################################
# Subroutines

# string of expected argument formats, followed by argument list
# prints error message for any mismatch.
# returns args if all OK.
# otherwise returns nothing.
# "v a b", ("arg1", "arg2", "arg3", "arg4)
# argument formats are:
# v - virtual drive number
# h - existing file in host filesystem
# nh - file in host filesystem (may or may not exist)
# of - optional file format: dsk or img, also inferred from h
# fs - flex file specifier: 1 or 1.foo.bar
sub check_arg {
    my @expected = split " ",(shift @_);
    my $host_file;  # stored for use by subsequent 'of' argument
    my $i = 0;
    foreach my $f (@expected) {
        if ($f eq 'v') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected virtual drive number\n";
                return;
            }
            if (($_[$i] ne "0") and ($_[$i] ne "1") and
                ($_[$i] ne "2") and($_[$i] ne "3")) {
                print "ERROR $_[$i] is not a legal virtual drive number\n";
                return;
            }
        }
        elsif ($f eq 'h') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            if (open my $tmp, '+<', $_[$i]) {
                # all good
                close $tmp;
                # 'of' will use this
                $host_file = $_[$i];
            }
            else {
                print "ERROR could not open $_[$i]\n";
                return;
            }
        }
        elsif ($f eq 'nh') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            # file may not exist so open for output
            if (open my $tmp, '>', $_[$i]) {
                # all good
                close $tmp;
                # 'of' will use this
                $host_file = $_[$i];
            }
            else {
                print "ERROR could not open $_[$i]\n";
                return;
            }
        }
        elsif ($f eq 'of') {
            # optional format. If present, takes precedence and must be img or dsk
            # If absent, inferred from file extension of host file. Incoming
            # arguments changed to declare the format.

            if ((defined $_[$i]) && (($_[$i] eq 'img') or ($_[$i] eq 'dsk'))) {
                # explicit format takes priority. Nothing more to do.
            }
            else {
                # extract extension from host file.. which is required to
                # occur earlier in the argument list.
                my @ext = split /\./, $host_file;
                if ((defined $ext[-1]) && (($ext[-1] eq 'img') or ($ext[-1] eq 'dsk'))) {
                    # change incoming argument so it's always present/valid
                    $_[$i] = $ext[-1];
                }
                else {
                    print "ERROR could not infer format. Specify dsk or img\n";
                    return;
                }
            }
        }
        elsif ($f eq 'fs') {
            # Flex file specifier
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected flex file specifier\n";
                return;
            }
            if (($_[$i] eq "0") or ($_[$i] eq "1") or
                ($_[$i] eq "2") or ($_[$i] eq "3")) {
                # make it more regular and we're done
                $_[$i] = "$_[$i].*.*";
            }
            # From Flex User Manual
            # 0-3 for drive, 1-8 character name, 1-3 character extension
            # extension must start with a letter
            # otherwise both can contain 0-9 a-z A-Z _ -
            # in addition, name and extension can contain * to wildcard.
            if ($_[$i] !~ /^[0123]\.[\*\w\-]{1,8}\.[\*a-zA-Z][\*\w\-]{0,2}$/) {
                print "ERROR $_[$i] is not a legal file specifier\n";
                return;
            }
        }
        else {
            die "FATAL internal error - unknown format $f\n";
        }
        $i = $i + 1;
    }
    return @_;
}


# copy zero or more files
# files specified by list of directory indices
sub cp_files {
    my ($src, $match, $dst) = @_;

    foreach my $i (@{$match}) {
        my $j = $dsk[$src]->{dir}->[$i];
        print "TODO copy file $src.$j->{NAME}.$j->{EXT} to $dst\n";
    }
}


# delete zero or more files
# files specified by list of directory indices
sub rm_files {
    my ($drive, $match) = @_;

    foreach my $i (@{$match}) {
        my $j = $dsk[$drive]->{dir}->[$i];
        print "TODO delete file $drive.$j->{NAME}.$j->{EXT}\n";
    }
}


# read a sector, return data as a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and read 1st copy of the data
sub rd_dts {
    my ($drive, $trk, $sct) = @_;
    my $seek;
    my $data;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        if ($trk > $dsk[$drive]->{sir}->{MAX_T}) {
            die "FATAL ERROR track $trk is out of range";
        }
        if ($sct > $dsk[$drive]->{sir}->{MAX_S}) {
            die "FATAL ERROR sector $sct is out of range";
        }

        $seek = (($sct - 1) + ($trk * $dsk[$drive]->{sir}->{MAX_S})) * $dsk[$drive]->{bytes_blk};
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $got = read $dsk[$drive]->{handle}, $data, $flx{BYTES_SECTOR};
        if ($got == $flx{BYTES_SECTOR}) {
            return $data;
        }
        else {
            # TODO BUG: this makes it a fatal error to mount a bad file. Fix that!
            die "Could not read $flx{BYTES_SECTOR} bytes at offset $seek on drive $drive";
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}


# write a sector, incoming data is a string.
# sector specified by drive,track,sector
# If disk in dsk format, it's 256 bytes per sector.
# If disk in img format, seek twice as far and write 2 copies of the data
sub wr_dts {
    my ($drive, $trk, $sct, $data) = @_;
    my $seek;
    if ($trk == 0) {
        # don't need to know geometry
        $seek = ($sct - 1) * $dsk[$drive]->{bytes_blk};
    }
    else {
        if ($trk > $dsk[$drive]->{sir}->{MAX_T}) {
            die "FATAL ERROR track $trk is out of range";
        }
        if ($sct > $dsk[$drive]->{sir}->{MAX_S}) {
            die "FATAL ERROR sector $sct is out of range";
        }

        $seek = (($sct - 1) + ($trk * $dsk[$drive]->{sir}->{MAX_S})) * $dsk[$drive]->{bytes_blk};
    }
    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $fh = $dsk[$drive]->{handle};
        print $fh $data;
        if ($dsk[$drive]->{bytes_blk} != $flx{BYTES_SECTOR}) {
            # 2nd copy
            print $fh $data;
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}

# decode bytes of the sir into a data structure that makes it
# easy to access
sub rd_sir {
    my $drive = $_[0];

    my $sir = $dsk[$drive]->{sir}->{data};

    # SIR format is described in section 9.1.5 of the 6809FAG
    $dsk[$drive]->{sir}->{LNK}     = 256 * $sir->[0] + $sir->[1];
    my $name = '';
    for my $i (16..16+11-1) {
        $name = $name . chr $dsk[$drive]->{sir}->{data}->[$i];
    }
    $dsk[$drive]->{sir}->{NAME}    = $name;
    $dsk[$drive]->{sir}->{NUM}     = 256 * $sir->[27] + $sir->[28];
    $dsk[$drive]->{sir}->{FIRST_T} = $sir->[29];
    $dsk[$drive]->{sir}->{FIRST_S} = $sir->[30];
    $dsk[$drive]->{sir}->{LAST_T}  = $sir->[31];
    $dsk[$drive]->{sir}->{LAST_S}  = $sir->[32];
    $dsk[$drive]->{sir}->{FREE}    = 256 * $sir->[33] + $sir->[34];
    $dsk[$drive]->{sir}->{DATE_M}  = $sir->[35];
    $dsk[$drive]->{sir}->{DATE_D}  = $sir->[36];
    $dsk[$drive]->{sir}->{DATE_Y}  = $sir->[37] %100; # Y2K fixup
    $dsk[$drive]->{sir}->{MAX_T}   = $sir->[38];
    $dsk[$drive]->{sir}->{MAX_S}   = $sir->[39];

    # need to make a guess now so that the directory can be inspected. Verify the guess
    # later on and confess if we got it wrong.
    $dsk[$drive]->{sir}->{T1_OFFSET} = $dsk[$drive]->{sir}->{MAX_S};
}

# Dump the SIR in human-readable format
sub describe_sir {
    my $drive = $_[0];
    my $i = "        ";

    printf "$i Image size:   %d blocks (%d bytes)\n",
    $dsk[$drive]->{blks}, $dsk[$drive]->{blks} * $dsk[$drive]->{bytes_blk};
# TODO
#        printf "%d blocks with data first/second half mismatches\n", $dsk[$drive]->{sir}->{SDMISMATCH};

    printf "$i Disk name:   %12s\n", $dsk[$drive]->{sir}->{NAME};
    printf "$i Disk number:  %d\n",  $dsk[$drive]->{sir}->{NUM};
    printf "$i Disk date:    %02d-%02d-%02d\n", $dsk[$drive]->{sir}->{DATE_M},
    $dsk[$drive]->{sir}->{DATE_D}, $dsk[$drive]->{sir}->{DATE_Y};
    printf "$i Free sectors: %d. Free chain t%02d,s%02d - t%02d,s%02d\n",
    $dsk[$drive]->{sir}->{FREE},
    $dsk[$drive]->{sir}->{FIRST_T}, $dsk[$drive]->{sir}->{FIRST_S},
    $dsk[$drive]->{sir}->{LAST_T}, $dsk[$drive]->{sir}->{LAST_S};
    printf "$i Range:        t00-t%02s, s01-s%02s\n",
    $dsk[$drive]->{sir}->{MAX_T}, $dsk[$drive]->{sir}->{MAX_S};
    printf "$i Trk0 sectors: $dsk[$drive]->{sir}->{T1_OFFSET}\n";
}


# read directory and attach data structure to $dsk
sub rd_dir {
    my $drive = $_[0];

    # Directory format is described in FLEXAPG. This is the first sector.
    my $trk = 0;
    my $sct = 5;

    my @dir;

    while (($trk != 0) or ($sct != 0)) {
        # process a directory sector
        my $data = rd_dts($drive, $trk, $sct);
        my @data = unpack("C*", $data);

        my $offset = 16;
        foreach my $entry(0..9) {
            my %d;

            # first byte of filename is 0 if it has never been used
            # or has bit 7 set if it has been deleted.
            my $nstart = 4 -4+$offset+($entry*24);
            my $first = ord substr($data, $nstart, 1);
            next if (($first == 0) || ($first & 0x80));

# TODO convert to ONLY use @data instead
            # the name can be null-terminated, which is non-printing but tidiest to remove them
            my $name = substr($data, $nstart, 8);
            $name =~ /(^[a-zA-Z0-9\-\_]+)/;
            $d{NAME} = $1;

            # likewise the extension
            my $ext = substr($data, $nstart+8, 3);
            $ext =~ /(^[a-zA-Z]+)/;
            $d{EXT} = $1;

            $d{ATTR}    = $data[15-4+$offset+($entry*24)];
            $d{FIRST_T} = $data[17-4+$offset+($entry*24)];
            $d{FIRST_S} = $data[18-4+$offset+($entry*24)];
            $d{LAST_T}  = $data[19-4+$offset+($entry*24)];
            $d{LAST_S}  = $data[20-4+$offset+($entry*24)];
            $d{SIZE}    = 256 * $data[21+0-4+$offset+($entry*24)] +
                                $data[21+1-4+$offset+($entry*24)];
            $d{FSM}     = $data[23-4+$offset+($entry*24)];
            $d{DATE_M}  = $data[25+0-4+$offset+($entry*24)];
            $d{DATE_D}  = $data[25+1-4+$offset+($entry*24)];
            $d{DATE_Y}  = $data[25+2-4+$offset+($entry*24)] %100; # Y2K fixup

            push @dir,\%d;
        }
        # next
        $trk = $data[0];
        $sct = $data[1];
    }
    $dsk[$drive]->{dir} = \@dir;
}


# Given a drive number and (potentially wildcarded) file name/extension,
# return a reference to a list of the directory entries that match.
sub filter_dir {
    my ($drive, $file, $ext) = @_;
    my @matches;

    # turn the file specifier into a legal PERL regex: * -> [-\w]*
    $file =~ s|\*|\[-\\w\]\*|g;
    $ext =~  s|\*|\[-\\w\]\*|g;

    for my $i (0.. $#{$dsk[$drive]->{dir}}) {
        if (($dsk[$drive]->{dir}->[$i]->{NAME} =~ /^$file$/)
            and ($dsk[$drive]->{dir}->[$i]->{EXT} =~ /^$ext$/)) {
            push @matches, $i;
        }
    }
    return \@matches;
}


# $files1 is a list of indices to files on $drive1. Look for
# filename matches on $drive2 and return a reference to a
# list of the directory entries that match - that list
# corresponds to indices in drive2, NOT drive1.
sub exact_match_dir {
    my ($drive1, $files1, $drive2) = @_;
    my @matches;
    my %drive1_names;

    # build a hash of the names we're looking for
    foreach my $i (@{$files1}) {
        my $name = "$dsk[$drive1]->{dir}->[$i]->{NAME}.$dsk[$drive1]->{dir}->[$i]->{EXT}";
        $drive1_names{$name} = 1;
    }

    for my $i (0.. $#{$dsk[$drive2]->{dir}}) {
        my $name = "$dsk[$drive2]->{dir}->[$i]->{NAME}.$dsk[$drive2]->{dir}->[$i]->{EXT}";
        if (exists $drive1_names{$name}) {
            push @matches, $i;
        }
    }

    return \@matches;
}


# sum the sectors needed to hold the specified files
sub sectors {
    my ($drive, $match) = @_;
    my $sum = 0;

    foreach my $i (@{$match}) {
        $sum = $sum + $dsk[$drive]->{dir}->[$i]->{SIZE};
    }

    return $sum;
}


sub help_for {
    my $cmd = $_[0];
    if ($cmd eq 'mount') {
        print <<EOF
    mount <virtual drive number> <file on host filesystem> [format]

    Associate a file on the host filesystem with a virtual drive number.

    Virtual drive number is 0,1,2 or 3.

    Legal formats are dsk and img (use "help formats" for
    more information).

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    Examples:
    mount 1 ../../foo.dsk
    mount 0 advent.dsk
    mount 2 system.img
    mount 0 flex09.zzz img
    mount 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'clone') {
        print <<EOF
    clone <virtual drive number> <file on host filesystem> [format]

    Make a copy of a virtual drive as a file on the host filesystem

    Virtual drive number is 0,1,2 or 3.
    Legal formats are "dsk" (256 bytes per sector) and "img" (256
    bytes per sector but doubled, on a 512-byte boundary)

    If the file extension is .dsk or .img the format is inferred and
    the format is optional.

    If the format is specified, it overrides any inference made on
    the basis of the file extension.

    If the format is different from the format of the virtual drive,
    format conversion will be performed.

    Examples:
    clone 1 ../../foo.dsk
    clone 0 advent.dsk
    clone 2 system.img
    clone 0 flex09.zzz img
    clone 0 flex09.dsk dsk
EOF
    }
    elsif ($cmd eq 'umount') {
        print <<EOF
    umount <virtual drive number>

    Close file associated with virtual drive number and make that virtual
    drive number available for reuse.

    Examples:
    umount 0
    umount 2
EOF
    }
    elsif ($cmd eq 'new') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'copy') {
        print <<EOF
    copy <file specifier> <virtual drive specifier>

    Copy all of the files that match the file specifier (source)
    to the specified virtual drive (destination). Any files of
    the same name on the specified virtual drive are deleted.

    The syntax of this command does not allow the name of the
    file to be changed as a side-effect of the copy. Therefore,
    it is not legal for the source drive to match the destination
    drive. This restriction may be removed in the future.

    Examples:
    copy 2 3
    copy 2.*.* 3
    copy 2.*.CMD 3
    copy 1.FLEX.SYS 2
EOF
    }
    elsif ($cmd eq 'label') {
        print <<EOF
    label <virtual drive number> mydisk

    change the label for the specified virtual drive number. The
    label is truncated after TODO characters.

    Example:
    label 1 mydisk
    label 0 flex_09
EOF
    }
    elsif ($cmd eq 'export') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'import') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'dir') {
        print <<EOF
    dir <virtual drive number> | <file specifier>

    List all of the files on the specified virtual drive, or
    all of the files that match the file specifier. The file
    specifier can include * used as a wildcard.

    Examples:
    dir 2
    dir 1.FLEX.SYS
    dir 1.F*.*
    dir 1.*.CMD
    dir 1.*A*.*
EOF
    }
    elsif ($cmd eq 'delete') {
        print <<EOF
    delete <virtual drive number> | <file specifier>

    Delete all of the files on the specified virtual drive, or
    all of the files that match the file specifier. The file
    specifier can include * used as a wildcard.

    BE CAREFUL BECAUSE NO CONFIRMATION IS ASKED FOR!

    Examples:
    delete 2
    delete 1.FLEX.SYS
    delete 1.F*.*
    delete 1.*.CMD
    delete 1.*A*.*
EOF
    }
    elsif ($cmd eq 'link') {
        print <<EOF
    link <file specifier>

    Patch the boot sector of the disk holding the specified
    file (usually FLEX.SYS) so that a subsequent boot of the
    system will load and start the specified file.

    Example:
    link 1.FLEX.SYS
    link 1.F*

    Wildcarding will generate an error if it resolves to more
    than one file.

    Background:
    use "help wrboot" for background on the Flex boot sector.
EOF
    }
    elsif ($cmd eq 'fix') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'rdboot') {
        print <<EOF
    rdboot <virtual drive number>

    Read the boot sector from the specified virtual drive. It is
    then available for use by the wrboot command.
EOF
    }
    elsif ($cmd eq 'wrboot') {
        print <<EOF
    wrboot <virtual drive number>

    Write the current boot loader (read using the rdboot or
    rdbootfile commands) to the boot sector of the specified
    virtual drive. After doing this, you will need to use the
    link command in order to make the disk bootable.

    Examples:
    rdboot 2
    wrboot 1
    link 1.FLEX.SYS

    Background:
    Track 0 sector 1 of a Flex disk is designated as the Flex boot
    sector, and usually holds the Flex boot loader -- this is
    target system dependent as some systems boot straight from ROM
    with no need for this intermediate bootstrap. Other systems may
    have a loader that extends beyond this one sector. A Flex boot
    loader is designed to load at address \$C100 and to be executed
    from that address. The bytes at address \$C105, \$C106 specify
    the track and sector at which the Flex image (usually named
    FLEX.SYS) is stored on the disk.

    The Flex LINK command (and the flex_vfs link command) locate
    a named file (eg FLEX.SYS) and patch the boot sector with the
    start track/sector of that image. This makes the function of
    the boot loader simpler.
EOF
    }
    elsif ($cmd eq 'rdbootfile') {
        print <<EOF
    rdbootfile <file on host filesystem>

    Read a binary blob (required to be exactly 256 bytes in size). It
    is then available for use by the wrboot command.
EOF
    }
    elsif ($cmd eq 'check') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'scrub') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'repair') {
        print <<EOF
TODO
EOF
    }
    elsif ($cmd eq 'formats') {
        print <<EOF
    Flex disks use a fixed sector size of 256 bytes, but varying
    geometries (the sector count and head count). Since the geometry
    is described within the SIR on the 3rd sector of the disk, it's
    possible to write a disk driver that can read the geometry from
    the SIR and then access any track/sector correctly. Thanks to
    this far-sight on behalf of the Flex designers, a Flex disk
    image can simply be represented as a sequence of 256-byte
    blocks and is "self-describing" thanks to its SIR. The normal
    file extension used for a Flex disk in this format is .dsk.

    In order to use an SDcard as a virtual floppy disk, it's
    necessary to translate between the track/sector number (which
    the Flex disk routines understand) and a linear block number
    (which the SDcard addressing understands). Also, the block
    size on an SDcard is 512 bytes.

    It would be possible to store 2 Flex sectors in each SDcard
    block but it is simpler (though inefficient) to store each
    sector in the first half of a 512 byte block. This has the
    effect of generating an image that is exactly twice the size
    of the .dsk file. In flex_vfs, the file extension used for
    this double-sized file is .img.

    flex_vfs can mount .img and .dsk files and can convert from
    one to the other using the clone command.

    For no particularly good reason (but maybe for integrity
    checking later) flex_vfs stores 2 copies of a Flex sector in
    each SDcard block. On reads, the first copy is used.
EOF
    }
    else {
        # no more to say about info, help, exit (or any non-existent command)
        print <<EOF
    No additional help is available on that topic
EOF
    }
}


sub help_generic {
    print <<EOF

flex_vfs allows manipulation of up to 4 virtual drives, numbered 0 through 3.
Each drive can be associated with a file on the host filesystem. Files
can be copied between virtual drives or transferred between virtual drives
and the host filesystem. Virtual drives can be inspected and manipulated.

Commands are:

    mount      - associate disk image with virtual drive number
    clone      - make copy of virtual drive (optional format conversion)
    info       - report virtual drives currently mounted
    umount     - disconnect disk image from drive number
    new        - create new empty disk image (optional geometry specification)
    copy       - copy file(s) from one virtual drive to another
    label      - change disk label
    export     - copy file from virtual drive to local file system (optional format conversion)
    import     - copy file from local file system to virtual drive (optional format conversion)
    dir        - directory of virtual drive
    delete     - delete file(s) from virtual drive
    link       - patch boot sector on virtual drive
    fix        - perform low-level edit on virtual drive
    rdboot     - copy boot sector from virtual drive
    wrboot     - write boot sector to virtual drive
    rdbootfile - read boot sector from file on local file system
    check      - check integrity of virtual drive
    scrub      - null out deleted file names and unused sectors
    repair     - repair virtual drive
    exit       - unmount all mounted drives and leave flex_vfs
    quit       - synonym for exit
    help       - this is it.

Type help <command name> for more help.
EOF
}




#########------------
sub help_exit {
    print <<EOF

Virtual file system for FLEX disk images.

> new 0 fred.dsk t=45 s=90
> copy 1.temp.txt 2
> export 2.advent.c textconvert
> export 2.advent.c binconvert
> import 2.test.txt ../../hello.c textconvert
> import 3.file.cmd file.bin binconvert
> dir 1
> dir 2
> copy 1.*.cmd 2
> delete 1.fred.bin
> delete 2.*.bin
> fix 1.flex.sys
> rdboot 1
> wrboot 2
> rdbootfile multicomp_flex_loader.bin
> check 1
> check 2
> exit
>

EOF
}

